Yo recuerdo que ya te habia pedido la modificación de esto, de los errores controlados, que el API del proveedor esté caido...
debe ser un error controlado, dime que otras cosas deberian tomarse en cuenta para manejarlo como error controlado, porque entonces estamos 
manejando muy pocos errores y muy pocos logs (o al menos con poca información) Por ejemplo: 

Mira este log de ejemplo:
_logger.Debug($"Respuesta: {StatusCode(StatusCodes.Status200OK, response)}");


En el log me gustaria tener la estructura del request que se forma, para enviarle al proveedor, siento que seria de apoyo si en algun momento hay un errror y tambien la estructura con la que response el proveedor, asi cruda sin transformarla.

El manejo de errores bien especifico si es importante, para que no caiga en el errror 500 de una vez, al menos eso es lo que yo pienso. 

Te dejo mis archivos:



using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using transacciones_flotantes.DTOs.TransaccionesFlotantes;
using transacciones_flotantes.Service.Interface;

namespace transacciones_flotantes.Controllers.TransaccionesFlotantes
{
    // [Route("api/[controller]")]

    [ApiController]
    [Route("api/transacciones-flotantes")]
    public class TransaccionesFlotantesController : ControllerBase
    {
        private readonly ITransaccionesFlotantesService _service;
        private readonly ILogger<TransaccionesFlotantesController> _logger;

        public TransaccionesFlotantesController(
            ITransaccionesFlotantesService service,
            ILogger<TransaccionesFlotantesController> logger)
        {
            _service = service;
            _logger = logger;
        }

        [HttpPost]
        public async Task<IActionResult> Procesar(
      [FromBody] TransaccionesFlotantesRequestDto request)
        {
            _logger.LogInformation("Request recibido en controller");

            try
            {
                var response = await _service.ProcesarAsync(request);
                return Ok(response);
            }
            catch (Exception ex)
            {
                _logger.LogCritical(ex, "Error 500 no controlado");
                return StatusCode(500, new
                {
                    codigo = 500,
                    mensaje = "Error interno del sistema"
                });
            }
        }
    }







    ------


    using System.Text.Json;
using transacciones_flotantes.DTOs.Response;
using transacciones_flotantes.DTOs.TransaccionesFlotantes;
using transacciones_flotantes.Repository.Interface;
using transacciones_flotantes.Service.Interface;
using static transacciones_flotantes.DTOs.Response.ResponseDto;
using static transacciones_flotantes.DTOs.TransaccionesFlotantes.ProveedorTransaccionesFlotantesResponseDto;

namespace transacciones_flotantes.Service
{
    public class TransaccionesFlotantesService : ITransaccionesFlotantesService
    {
        private readonly ITransaccionFlotanteRepository _repository;
        private readonly IProveedorApiClient _proveedorClient;
        private readonly ICatalogoErroresRepository _catalogoErrores;
        private readonly ILogger<TransaccionesFlotantesService> _logger;
        private readonly ICurrencyService _currencyService;

        public TransaccionesFlotantesService(
            ITransaccionFlotanteRepository repository,
            IProveedorApiClient proveedorClient,
            ICatalogoErroresRepository catalogoErrores,
            ILogger<TransaccionesFlotantesService> logger,
            ICurrencyService currencyService)
        {
            _repository = repository;
            _proveedorClient = proveedorClient;
            _catalogoErrores = catalogoErrores;
            _logger = logger;
            _currencyService = currencyService;
        }

        public async Task<LegacyTransaccionesResponseDto> ProcesarAsync(
            TransaccionesFlotantesRequestDto request)
        {
            _logger.LogInformation("Inicio procesamiento transacciones flotantes");

            try
            {
                // Obtener datos del proveedor
                var data = await _repository.ObtenerDatosProveedorAsync(request.CounterpartCard);
                if (data == null)
                {
                    _logger.LogWarning("Datos del proveedor no encontrados para {CounterpartCard}", request.CounterpartCard);
                    return await CrearRespuestaError(2);
                }

                // Construir request para proveedor
                var proveedorRequest = new ProveedorTransaccionFlotanteRequestDto
                {
                    Card = new()
                    {
                        Bin = data.Bin,
                        UltimosCuatroDigitos = data.UltimosCuatroDigitos
                    },
                    Client = new()
                    {
                        NumeroDocumento = data.NumeroDocumento,
                        TipoDocumento = data.TipoDocumento,
                        Sexo = data.Sexo
                    }
                };

                // Enviar request al proveedor
                var rawResponse = await _proveedorClient.EnviarTransaccionAsync(proveedorRequest);

                // Deserializar respuesta
                var proveedorData = JsonSerializer.Deserialize<ProveedorResponseDto>(rawResponse)
                    ?? throw new Exception("Respuesta inválida del proveedor");

                if (!proveedorData.Authorizations.Any())
                {
                    _logger.LogWarning("Proveedor respondió sin autorizaciones");
                    return await CrearRespuestaError(2);
                }

                _logger.LogInformation("Autorizaciones recibidas: {Cantidad}", proveedorData.Authorizations.Count);

                // Obtener catálogo de código 1 (éxito)
                var catalogo = await _catalogoErrores.GetCatalogoResponseAsync(1);

                // Procesar autorizaicones y resolver moneda
                var listaRespuesta = await Task.WhenAll(proveedorData.Authorizations.Select(async a => new LegacyAutorizacionDto
                {
                    Date = a.Date,
                    Merchant_Name = a.Merchant_Name,
                    Amount = a.Amount,
                    Currency = await _currencyService.ResolverAsync(a.Currency),
                    Reference = a.Reference
                }));

                return new LegacyTransaccionesResponseDto
                {
                    Result =
                    {
                        Codigo = catalogo.Codigo,
                        Descripcion = catalogo.Descripcion
                    },
                    Respuesta = listaRespuesta.ToList()
                };
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error no controlado en el servicio");
                throw;
            }
        }

        private async Task<LegacyTransaccionesResponseDto> CrearRespuestaError(int codigo)
        {
            var catalogo = await _catalogoErrores.GetCatalogoResponseAsync(codigo);

            return new LegacyTransaccionesResponseDto
            {
                Result =
                {
                    Codigo = catalogo.Codigo,
                    Descripcion = catalogo.Descripcion
                },
                Respuesta = 0
            };
        }
    }
}





----


using System.Text.Json;
using transacciones_flotantes.Service.Interface;

namespace transacciones_flotantes.Service
{
    public class ProveedorTokenService : IProveedorTokenService
    {
        private readonly HttpClient _httpClient;
        private readonly IConfiguration _configuration;
        private readonly ILogger<ProveedorTokenService> _logger;

        private string? _token;
        private DateTime _expiracion;

        public ProveedorTokenService(HttpClient httpClient, IConfiguration configuration, ILogger<ProveedorTokenService> logger)
        {
            _httpClient = httpClient;
            _configuration = configuration;
            _logger = logger;
        }

        public async Task<string> ObtenerAccessTokenAsync()
        {
            if (!string.IsNullOrEmpty(_token) && DateTime.UtcNow < _expiracion.AddSeconds(-10))
            {
                _logger.LogInformation("Token vigente reutilizado");
                return _token;
            }

            _logger.LogInformation("Solicitando nuevo token al proveedor");

            var response = await _httpClient.PostAsync(
                _configuration["Proveedor:TokenUrl"],
                new FormUrlEncodedContent(new Dictionary<string, string>
                {
            { "client_id", _configuration["Proveedor:ClientId"] },
            { "client_secret", _configuration["Proveedor:ClientSecret"] },
            { "grant_type", "client_credentials" }
                })
            );

            response.EnsureSuccessStatusCode();

            var json = await response.Content.ReadAsStringAsync();
            var tokenResponse = JsonSerializer.Deserialize<JsonElement>(json);

            _token = tokenResponse.GetProperty("access_token").GetString();
            var expiresIn = tokenResponse.GetProperty("expires_in").GetInt32();

            _expiracion = DateTime.UtcNow.AddSeconds(expiresIn);

            _logger.LogInformation("Token obtenido correctamente");

            return _token!;
        }
    }
}




------


using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using transacciones_flotantes.DTOs.TransaccionesFlotantes;
using transacciones_flotantes.Service.Interface;

namespace transacciones_flotantes.Service
{
    public class ProveedorApiClient : IProveedorApiClient
    {
        private readonly HttpClient _httpClient;
        private readonly IProveedorTokenService _tokenService;
        private readonly IConfiguration _configuration;
        private readonly ILogger<ProveedorApiClient> _logger;

        public ProveedorApiClient(HttpClient httpClient, IProveedorTokenService tokenService,
            IConfiguration configuration, ILogger<ProveedorApiClient> logger)
        {
            _httpClient = httpClient;
            _tokenService = tokenService;
            _configuration = configuration;
            _logger = logger;
        }

        public async Task<string> EnviarTransaccionAsync(ProveedorTransaccionFlotanteRequestDto request)
        {
            _logger.LogInformation("Iniciando consumo de API proveedor");

            var token = await _tokenService.ObtenerAccessTokenAsync();

            var httpRequest = new HttpRequestMessage(
                HttpMethod.Post,
                _configuration["Proveedor:TransaccionesUrl"]);

            httpRequest.Headers.Authorization =
                new AuthenticationHeaderValue("Bearer", token);

            httpRequest.Content = new StringContent(
                JsonSerializer.Serialize(request),
                Encoding.UTF8,
                "application/json");

            var response = await _httpClient.SendAsync(httpRequest);

            _logger.LogInformation(
                "Respuesta proveedor HTTP {StatusCode}",
                response.StatusCode);

            response.EnsureSuccessStatusCode();

            return await response.Content.ReadAsStringAsync();
        }
    }
}


---------


using System.Data;
using Microsoft.Data.SqlClient;
using Dapper;
using transacciones_flotantes.Models.TransaccionesFlotantes;
using transacciones_flotantes.Repository.Interface;


namespace transacciones_flotantes.Repository
{
    public class TransaccionFlotanteRepository : ITransaccionFlotanteRepository
    {
        private readonly IConfiguration _configuration;
        private readonly ILogger<TransaccionFlotanteRepository> _logger;

        public TransaccionFlotanteRepository(
            IConfiguration configuration,
            ILogger<TransaccionFlotanteRepository> logger)
        {
            _configuration = configuration;
            _logger = logger;
        }

        public async Task<TransaccionFlotanteProveedorDataModel?>
            ObtenerDatosProveedorAsync(string counterpartCard)
        {
            _logger.LogInformation(
                "Buscando datos del proveedor para tarjeta terminada en {Ultimos4}",
                counterpartCard[^4..]);

            using var connection =
                new SqlConnection(_configuration.GetConnectionString("DefaultConnection"));

            var result = await connection.QueryFirstOrDefaultAsync<
                TransaccionFlotanteProveedorDataModel>(
                "sp_ObtenerDatosTransaccionFlotante",
                new { CounterpartCard = counterpartCard },
                commandType: CommandType.StoredProcedure
            );

            if (result == null)
                _logger.LogWarning(
                    "No se encontraron datos del proveedor para la tarjeta solicitada");

            return result;
        }
    }
}
