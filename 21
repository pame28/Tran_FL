CREATE TABLE CatalogoErrores (
    Codigo INT PRIMARY KEY,
    Descripcion VARCHAR(255) NOT NULL
);









INSERT INTO CatalogoErrores (Codigo, Descripcion)
VALUES
(1, 'True'),
(2, 'No se encontraron registros'),
(5, 'Error al consumir proveedor'),
(99, 'Error interno del sistema');










CREATE PROCEDURE SP_GetCatalogoResponse
    @error_code INT
AS
BEGIN
    SET NOCOUNT ON;

    SELECT 
        Codigo,
        Descripcion
    FROM CatalogoErrores
    WHERE Codigo = @error_code;
END







namespace transacciones_flotantes.Models.Catalogo
{
    public class CatalogoResponse
    {
        public int Codigo { get; set; }
        public string Descripcion { get; set; } = string.Empty;
    }
}








using transacciones_flotantes.Models.Catalogo;

namespace transacciones_flotantes.Repository.Interface
{
    public interface ICatalogoErroresRepository
    {
        Task<CatalogoResponse> GetCatalogoResponseAsync(int codigo);
    }
}







using Dapper;
using Microsoft.Data.SqlClient;
using System.Data;
using transacciones_flotantes.Models.Catalogo;
using transacciones_flotantes.Repository.Interface;

namespace transacciones_flotantes.Repository
{
    public class CatalogoErroresRepository : ICatalogoErroresRepository
    {
        private readonly IConfiguration _configuration;
        private readonly ILogger<CatalogoErroresRepository> _logger;

        public CatalogoErroresRepository(
            IConfiguration configuration,
            ILogger<CatalogoErroresRepository> logger)
        {
            _configuration = configuration;
            _logger = logger;
        }

        public async Task<CatalogoResponse> GetCatalogoResponseAsync(int codigo)
        {
            try
            {
                using var connection =
                    new SqlConnection(_configuration.GetConnectionString("DefaultConnection"));

                var result = await connection.QueryFirstOrDefaultAsync<CatalogoResponse>(
                    "SP_GetCatalogoResponse",
                    new { error_code = codigo },
                    commandType: CommandType.StoredProcedure);

                _logger.LogInformation(
                    "Respuesta del catalogo cod:{Codigo} - {Descripcion}",
                    codigo,
                    result?.Descripcion
                );

                return result ?? new CatalogoResponse
                {
                    Codigo = 99,
                    Descripcion = "CÃ³digo de error no catalogado"
                };
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error al obtener los datos del error");
                return new CatalogoResponse
                {
                    Codigo = 99,
                    Descripcion = "Error interno del sistema"
                };
            }
        }
    }
}











namespace transacciones_flotantes.DTOs.Response
{
    public class ApiResponseDto<T>
    {
        public ResultDto Result { get; set; } = new();
        public T? Respuesta { get; set; }
    }

    public class ResultDto
    {
        public int Codigo { get; set; }
        public string Descripcion { get; set; } = string.Empty;
    }
}












namespace transacciones_flotantes.DTOs.Response
{
    public class TransaccionesFlotantesResponseDto
    {
        public TotalesFloatingDto Total_Floating { get; set; } = new();
        public List<AutorizacionDto> Respuesta { get; set; } = new();
    }

    public class TotalesFloatingDto
    {
        public string Total_HNL { get; set; } = "0";
        public string Total_USD { get; set; } = "0";
    }

    public class AutorizacionDto
    {
        public DateTime Date { get; set; }
        public string Merchant_Name { get; set; } = string.Empty;
        public decimal Amount { get; set; }
        public string Currency { get; set; } = string.Empty;
        public string? Reference { get; set; }
        public string Transaction_Type { get; set; } = string.Empty;
    }
}











using System.Text.Json;
using transacciones_flotantes.DTOs.Response;
using transacciones_flotantes.DTOs.TransaccionesFlotantes;
using transacciones_flotantes.Repository.Interface;
using transacciones_flotantes.Service.Interface;

namespace transacciones_flotantes.Service
{
    public class TransaccionesFlotantesService : ITransaccionesFlotantesService
    {
        private readonly ITransaccionFlotanteRepository _repository;
        private readonly IProveedorApiClient _proveedorClient;
        private readonly ICatalogoErroresRepository _catalogoErrores;
        private readonly ILogger<TransaccionesFlotantesService> _logger;

        public TransaccionesFlotantesService(
            ITransaccionFlotanteRepository repository,
            IProveedorApiClient proveedorClient,
            ICatalogoErroresRepository catalogoErrores,
            ILogger<TransaccionesFlotantesService> logger)
        {
            _repository = repository;
            _proveedorClient = proveedorClient;
            _catalogoErrores = catalogoErrores;
            _logger = logger;
        }

        public async Task<ApiResponseDto<object>> ProcesarAsync(
            TransaccionesFlotantesRequestDto request)
        {
            try
            {
                var data = await _repository.ObtenerDatosProveedorAsync(request.CounterpartCard);

                if (data == null)
                    return await CrearRespuestaError(2);

                var proveedorRequest = new ProveedorTransaccionFlotanteRequestDto
                {
                    Card = new()
                    {
                        Bin = data.Bin,
                        UltimosCuatroDigitos = data.UltimosCuatroDigitos
                    },
                    Client = new()
                    {
                        NumeroDocumento = data.NumeroDocumento,
                        TipoDocumento = data.TipoDocumento,
                        Sexo = data.Sexo
                    }
                };

                var rawResponse =
                    await _proveedorClient.EnviarTransaccionAsync(proveedorRequest);

                var proveedorData =
                    JsonSerializer.Deserialize<object>(rawResponse);

                var catalogo = await _catalogoErrores.GetCatalogoResponseAsync(1);

                return new ApiResponseDto<object>
                {
                    Result =
                    {
                        Codigo = catalogo.Codigo,
                        Descripcion = catalogo.Descripcion
                    },
                    Respuesta = proveedorData
                };
            }
            catch (HttpRequestException ex)
            {
                _logger.LogError(ex, "Error al consumir proveedor");
                return await CrearRespuestaError(5);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error no controlado");
                return await CrearRespuestaError(99);
            }
        }

        private async Task<ApiResponseDto<object>> CrearRespuestaError(int codigo)
        {
            var catalogo = await _catalogoErrores.GetCatalogoResponseAsync(codigo);

            return new ApiResponseDto<object>
            {
                Result =
                {
                    Codigo = catalogo.Codigo,
                    Descripcion = catalogo.Descripcion
                },
                Respuesta = 0
            };
        }
    }
}












using Microsoft.AspNetCore.Mvc;
using transacciones_flotantes.DTOs.TransaccionesFlotantes;
using transacciones_flotantes.Service.Interface;

namespace transacciones_flotantes.Controllers
{
    [ApiController]
    [Route("api/transacciones-flotantes")]
    public class TransaccionesFlotantesController : ControllerBase
    {
        private readonly ITransaccionesFlotantesService _service;

        public TransaccionesFlotantesController(
            ITransaccionesFlotantesService service)
        {
            _service = service;
        }

        [HttpPost]
        public async Task<IActionResult> Procesar(
            [FromBody] TransaccionesFlotantesRequestDto request)
        {
            var response = await _service.ProcesarAsync(request);
            return Ok(response);
        }
    }
}








