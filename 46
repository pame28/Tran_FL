using Microsoft.AspNetCore.Mvc;
using transacciones_flotantes.DTOs.TransaccionesFlotantes;
using transacciones_flotantes.Service.Interface;

namespace transacciones_flotantes.Controllers.TransaccionesFlotantes
{
    [ApiController]
    [Route("api/transacciones-flotantes")]
    public class TransaccionesFlotantesController : ControllerBase
    {
        private readonly ITransaccionesFlotantesService _service;
        private readonly ILogger<TransaccionesFlotantesController> _logger;

        public TransaccionesFlotantesController(
            ITransaccionesFlotantesService service,
            ILogger<TransaccionesFlotantesController> logger)
        {
            _service = service;
            _logger = logger;
        }

        [HttpPost]
        public async Task<IActionResult> Procesar(
            [FromBody] TransaccionesFlotantesRequestDto request)
        {
            _logger.LogInformation(
                "Request recibido. CounterpartCard: {Ultimos4}",
                request.CounterpartCard[^4..]);

            try
            {
                var response = await _service.ProcesarAsync(request);
                return Ok(response);
            }
            catch (Exception ex)
            {
                _logger.LogCritical(ex, "Error 500 no controlado");
                return StatusCode(500, new
                {
                    codigo = 500,
                    mensaje = "Error interno del sistema"
                });
            }
        }
    }
}












---------






using System.Text.Json;
using transacciones_flotantes.DTOs.Response;
using transacciones_flotantes.DTOs.TransaccionesFlotantes;
using transacciones_flotantes.Repository.Interface;
using transacciones_flotantes.Service.Interface;
using static transacciones_flotantes.DTOs.Response.ResponseDto;
using static transacciones_flotantes.DTOs.TransaccionesFlotantes.ProveedorTransaccionesFlotantesResponseDto;

namespace transacciones_flotantes.Service
{
    public class TransaccionesFlotantesService : ITransaccionesFlotantesService
    {
        private readonly ITransaccionFlotanteRepository _repository;
        private readonly IProveedorApiClient _proveedorClient;
        private readonly ICatalogoErroresRepository _catalogoErrores;
        private readonly ILogger<TransaccionesFlotantesService> _logger;
        private readonly ICurrencyService _currencyService;

        public TransaccionesFlotantesService(
            ITransaccionFlotanteRepository repository,
            IProveedorApiClient proveedorClient,
            ICatalogoErroresRepository catalogoErrores,
            ILogger<TransaccionesFlotantesService> logger,
            ICurrencyService currencyService)
        {
            _repository = repository;
            _proveedorClient = proveedorClient;
            _catalogoErrores = catalogoErrores;
            _logger = logger;
            _currencyService = currencyService;
        }

        public async Task<LegacyTransaccionesResponseDto> ProcesarAsync(
            TransaccionesFlotantesRequestDto request)
        {
            var start = DateTime.UtcNow;
            _logger.LogInformation("Inicio procesamiento");

            try
            {
                var data = await _repository.ObtenerDatosProveedorAsync(request.CounterpartCard);
                if (data == null)
                    return await CrearRespuestaError(2, "Datos proveedor no encontrados");

                var proveedorRequest = new ProveedorTransaccionFlotanteRequestDto
                {
                    Card = new()
                    {
                        Bin = data.Bin,
                        UltimosCuatroDigitos = data.UltimosCuatroDigitos
                    },
                    Client = new()
                    {
                        NumeroDocumento = data.NumeroDocumento,
                        TipoDocumento = data.TipoDocumento,
                        Sexo = data.Sexo
                    }
                };

                _logger.LogDebug(
                    "Request proveedor: {Json}",
                    JsonSerializer.Serialize(proveedorRequest));

                string rawResponse;

                try
                {
                    rawResponse = await _proveedorClient.EnviarTransaccionAsync(proveedorRequest);
                }
                catch (HttpRequestException ex)
                {
                    _logger.LogError(ex, "Proveedor no disponible");
                    return await CrearRespuestaError(3, "Proveedor no disponible");
                }
                catch (TaskCanceledException ex)
                {
                    _logger.LogError(ex, "Timeout proveedor");
                    return await CrearRespuestaError(4, "Timeout proveedor");
                }

                _logger.LogDebug("Response cruda proveedor: {Raw}", rawResponse);

                ProveedorResponseDto proveedorData;
                try
                {
                    proveedorData = JsonSerializer.Deserialize<ProveedorResponseDto>(rawResponse)
                        ?? throw new Exception("JSON vacío");
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "JSON inválido proveedor");
                    return await CrearRespuestaError(5, "Respuesta inválida proveedor");
                }

                if (!proveedorData.Authorizations.Any())
                    return await CrearRespuestaError(2, "Sin autorizaciones");

                var catalogo = await _catalogoErrores.GetCatalogoResponseAsync(1);

                var autorizaciones = await Task.WhenAll(
                    proveedorData.Authorizations.Select(async a => new LegacyAutorizacionDto
                    {
                        Date = a.Date,
                        Merchant_Name = a.Merchant_Name,
                        Amount = a.Amount,
                        Currency = await _currencyService.ResolverAsync(a.Currency),
                        Reference = a.Reference
                    }));

                _logger.LogInformation(
                    "Proceso exitoso. Tiempo: {Ms} ms",
                    (DateTime.UtcNow - start).TotalMilliseconds);

                return new LegacyTransaccionesResponseDto
                {
                    Result =
                    {
                        Codigo = catalogo.Codigo,
                        Descripcion = catalogo.Descripcion
                    },
                    Respuesta = autorizaciones.ToList()
                };
            }
            catch (Exception ex)
            {
                _logger.LogCritical(ex, "Error no controlado en servicio");
                throw;
            }
        }

        private async Task<LegacyTransaccionesResponseDto> CrearRespuestaError(
            int codigo, string detalle)
        {
            var catalogo = await _catalogoErrores.GetCatalogoResponseAsync(codigo);

            _logger.LogWarning(
                "Error controlado {Codigo}: {Detalle}",
                codigo, detalle);

            return new LegacyTransaccionesResponseDto
            {
                Result =
                {
                    Codigo = catalogo.Codigo,
                    Descripcion = catalogo.Descripcion
                },
                Respuesta = 0
            };
        }
    }
}












using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using transacciones_flotantes.DTOs.TransaccionesFlotantes;
using transacciones_flotantes.Service.Interface;

namespace transacciones_flotantes.Service
{
    public class ProveedorApiClient : IProveedorApiClient
    {
        private readonly HttpClient _httpClient;
        private readonly IProveedorTokenService _tokenService;
        private readonly IConfiguration _configuration;
        private readonly ILogger<ProveedorApiClient> _logger;

        public ProveedorApiClient(
            HttpClient httpClient,
            IProveedorTokenService tokenService,
            IConfiguration configuration,
            ILogger<ProveedorApiClient> logger)
        {
            _httpClient = httpClient;
            _tokenService = tokenService;
            _configuration = configuration;
            _logger = logger;
        }

        public async Task<string> EnviarTransaccionAsync(
            ProveedorTransaccionFlotanteRequestDto request)
        {
            var token = await _tokenService.ObtenerAccessTokenAsync();

            var httpRequest = new HttpRequestMessage(
                HttpMethod.Post,
                _configuration["Proveedor:TransaccionesUrl"]);

            httpRequest.Headers.Authorization =
                new AuthenticationHeaderValue("Bearer", token);

            httpRequest.Content = new StringContent(
                JsonSerializer.Serialize(request),
                Encoding.UTF8,
                "application/json");

            var response = await _httpClient.SendAsync(httpRequest);

            var body = await response.Content.ReadAsStringAsync();

            _logger.LogInformation(
                "Proveedor HTTP {StatusCode}",
                response.StatusCode);

            if (!response.IsSuccessStatusCode)
            {
                _logger.LogError(
                    "Proveedor error HTTP {StatusCode} - Body: {Body}",
                    response.StatusCode,
                    body);

                throw new HttpRequestException(
                    $"Proveedor respondió {response.StatusCode}");
            }

            return body;
        }
    }
}
















using System.Text.Json;
using transacciones_flotantes.Service.Interface;

namespace transacciones_flotantes.Service
{
    public class ProveedorTokenService : IProveedorTokenService
    {
        private readonly HttpClient _httpClient;
        private readonly IConfiguration _configuration;
        private readonly ILogger<ProveedorTokenService> _logger;

        private string? _token;
        private DateTime _expiracion;

        public ProveedorTokenService(
            HttpClient httpClient,
            IConfiguration configuration,
            ILogger<ProveedorTokenService> logger)
        {
            _httpClient = httpClient;
            _configuration = configuration;
            _logger = logger;
        }

        public async Task<string> ObtenerAccessTokenAsync()
        {
            if (!string.IsNullOrEmpty(_token)
                && DateTime.UtcNow < _expiracion.AddSeconds(-10))
            {
                _logger.LogDebug("Token reutilizado");
                return _token;
            }

            _logger.LogInformation("Solicitando token proveedor");

            var response = await _httpClient.PostAsync(
                _configuration["Proveedor:TokenUrl"],
                new FormUrlEncodedContent(new Dictionary<string, string>
                {
                    { "client_id", _configuration["Proveedor:ClientId"] },
                    { "client_secret", _configuration["Proveedor:ClientSecret"] },
                    { "grant_type", "client_credentials" }
                }));

            if (!response.IsSuccessStatusCode)
            {
                _logger.LogError("Error obteniendo token proveedor");
                throw new HttpRequestException("Error token proveedor");
            }

            var json = await response.Content.ReadAsStringAsync();
            var tokenResponse = JsonSerializer.Deserialize<JsonElement>(json);

            _token = tokenResponse.GetProperty("access_token").GetString();
            var expiresIn = tokenResponse.GetProperty("expires_in").GetInt32();

            _expiracion = DateTime.UtcNow.AddSeconds(expiresIn);

            return _token!;
        }
    }
}

